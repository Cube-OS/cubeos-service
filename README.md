# cubeos-service

This is an overhaul of the kubos-service. The main goal for this crate was to lighten the processing load for the OBC, 
which is achieved by substituting the original GraphQL commands with a simpler command handler via UDP.

The performance improvement comes with the sacrifice of the debugging qualities of GraphQL.
For this purpose the service has been redeveloped around the `service_macro!` to give the user the decision of 
lightweight UDP or GraphQL command handling at compile time. The UDP Handler is enabled by default. 

To compensate for the loss of GraphQL on the satellite, the cubeos-service comes with a third compilation option, called Ground.
The ground mode is run on a computer connected to the satellite, where it hosts a GraphQL Server. GraphQL inputs are translated 
to the UDP command and sent to the satellite. The satellite's reply is then translated into JSON. This enables the user to have
the usual human readable handling of GraphQL and the performance advantage of the UDP handling.

Additionally the debug feature enables some terminal printouts.

## service_macro!
** The use of the service-macro! is not necessary if you only wish to use the GraphQL functionality **
The `service_macro!` has the following structure:
```
service_macro!{
  query: $cmdid0 => fn function0(&self, $Inputs) -> Result<$Reply>; in: $GqlInput; out: $GqlReply;
  mutation: $cmdid1 => fn function1(&self, $Inputs) -> Result<$Reply>; in: $GqlInput; out: $GqlReply;
}
```
Where `$Input(s)` are the arguments for `function\_()` (leave blank if `function\_()` has no arguments). The whole part `fn function_(&self, args) -> Result<$Reply>` can be copied from the implementation of the function in the `subsytem.rs`. 

The denominators query and mutation are needed to differentiate between the commands in the Ground and GraphQL use cases.

Here the `cmdid` is an Enum variant of the `enum Command`, which is generated by the macro to enable command handling.

After the => comes the function of the Subsystem associated with the CommandID. 

Before describing the Result part it is now important to point out the $GqlInput at the end of the lines.
For queries and mutations the $GqlInput can be the same as the $Input, if it's an Enum. 
It is then necessary this enum has all the relevant #[derive(...)]. In case of a struct it is necessary to use a GraphQLType structure and implement the `TryFrom` Trait to convert $GqlInput to $Input:
```
#[derive(GraphQLObject)]
pub struct $GqlInput {
...
}
impl TryFrom<$GqlInput> for $Input {
  type Error = CubeOSError::Error;
  
  fn try_from(gql: $GqlInput) -> $Input {
    ...
  }
}
```
The amount of $GqlInputs and $Inputs has to match. 

Multiple $GqlInputs are chained like this: `in: $GqlInput0, $GqlInput1..`.
If the function does not take any inputs, the `in: ;` part is left blank.

The Result can be any Result Type, but the Error needs to be convertible to `CubeOSError::Error::ServiceError(u8)`. [CubeOSError](https://github.com/Cube-OS/cubeos-error).

The $Reply requires the #[derive(Serialize,Deserialize)] from the [serde_json](https://docs.serde.rs/serde_json/) crate.

The $GqlReply is additionally available to translate digital sensory data to human readable outputs. Similar to $GqlInput, this can be set to $Reply, where the response is already humanly readable (e.g. for `GenericResponse`, or Enum or String types).
It is necessary to implement the `From` Trait to convert $Reply to $GqlReply:
```
#[derive(GraphQLObject)]
pub struct $GqReply {
...
}
impl From<$Reply> for $GqlReply {
  fn from(gql: $Reply) -> $GqlReply {
    ...
  }
}
```

## Service
To accomodate the different use cases, the `Service` has been altered slightly as well. The following examples show how to start your service in `main.rs`:

In the default UDP case, the GraphQL Query and Mutationroot are replaced by the `udp_handler` function:
```
#[cfg(not(any(feature = "ground",feature = "graphql")))]
//Start up UDP server
Service::new(
    service_config,
    subsystem,
    Some(Arc::new(udp_handler)),
)
.start();
```

The ground case, doesn't need the Subsystem, but adds a socket IP address,
which can be any free Port on the Debug/GroundStation computer, and the target service's IP address on the satellite.
It is handy to read them in from a `config.toml` file, but not necessary.
```
#[cfg(feature = "ground")]
// Start ground service
Service::new(
    service_config,
    QueryRoot,
    MutationRoot,
    socket.as_str().unwrap().to_string(),
    target.as_str().unwrap().to_string(),
).start();
```

For GraphQL, the Service is unchanged to the original in the kubos-service, and consists of
Config, Subsystem, QueryRoot and MutationRoot: 
```
#[cfg(feature = "graphql")]
// Start up graphql server
Service::new(
    service_config,
    subsystem,
    QueryRoot,
    MutationRoot,
)
.start();
```

## Compile your service (requires rust 1.55.0 or above)
As shown above, **cubeos-service** uses features so the user can decide the use case at compile time.

**UDP handling**

`cargo build`

or with cross compiler

`cargo kubos -c build --target kubos-linux-isis-gcc -- --release` (requires KubOS SDK)

**GraphQL:**

`cargo build --features graphql`

or with cross complier 

`cargo kubos -c build --target kubos-linux-isis-gcc -- --release --features graphql` 

**Ground:**

`cargo build --features ground`

Additionally the UDP handling and Ground features can be combined with **debug**, e.g.:
`cargo build --features debug`
`cargo build --features ground,debug`

## Run a service
To run a service simply transfer the executable to the satellite or ground station to a desired folder (e.g. /home/kubos/) and run:

`./executable`

This requires a config file `/etc/kubos-config.toml`. Alternatively run the executable with the -c flag to specify a config file:

`./executable -c path/to/config`

## Troubleshooting
CubeOS uses git ssh URL's for dependencies within the Organisation. Pls make sure to add your to the repository:

**start ssh-agent**
```` eval `ssh-agent` ````

**add key (in repo)**
`ssh-add ~/.ssh/$your-key`
