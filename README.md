# cubeos-service

This is an overhaul of the kubos-service. The main goal for this crate was to lighten the processing load for the OBC, 
which is achieved by substituting the original GraphQL commands with a simpler command handler via UDP.

The performance improvement comes with the sacrifice of the debugging qualities of GraphQL.
For this purpose the service has been redeveloped around the `service_macro!` to replace the GraphQL server on the satellite 
with a lightweight UDP Handler. Instead the GraphQL server is now run on the Ground Station. This ground mode can be compiled
from the same source by using the `--features ground` flag.

The ground service translates GraphQL inputs to UDP commands and forwards them to the satellite. The satellite's reply is 
then translated into JSON. This enables the user to have the usual human readable handling of GraphQL and the performance 
advantage of the UDP handling.

Additionally the debug feature enables some terminal printouts.

## service_macro!
The `service_macro!` has the following structure:
```
service_macro!{
  $krate::$strukt {
    query: $cmdid0 => fn function0(&self, $Inputs) -> Result<$Reply>; in: $GqlInput; out: $GqlReply;
    mutation: $cmdid1 => fn function1(&self, $Inputs) -> Result<$Reply>; in: $GqlInput; out: $GqlReply;
  }
}
```
`$krate::$strukt` is the crate name and name of the struct (e.g. `subsystem::Subsystem`) containing the functions to be exposed by the Service.

`$Input(s)` are the arguments for `function\_()` (leave blank if `function\_()` has no arguments). The whole part `fn function_(&self, args) -> Result<$Reply>` can be copied from the implementation of the function in the `subsytem.rs`. 

The denominators query and mutation are needed to differentiate between the commands in the Ground and GraphQL use cases.

Here the `cmdid` is an Enum variant of the `enum Command`, which is generated by the macro to enable command handling.

After the => comes the function of the Subsystem associated with the CommandID. 

Before describing the Result part it is now important to point out the $GqlInput at the end of the lines.
For queries and mutations the $GqlInput can be the same as the $Input, if it's an Enum. 
It is then necessary this enum has all the relevant #[derive(...)]. In case of a struct it is necessary to use a GraphQLType structure and implement the `TryFrom` Trait to convert $GqlInput to $Input:
```
#[derive(GraphQLObject)]
pub struct $GqlInput {
...
}
impl TryFrom<$GqlInput> for $Input {
  type Error = CubeOSError::Error;
  
  fn try_from(gql: $GqlInput) -> $Input {
    ...
  }
}
```
The amount of $GqlInputs and $Inputs has to match. 

Multiple $GqlInputs are chained like this: `in: $GqlInput0, $GqlInput1..`.
If the function does not take any inputs, the `in: ;` part is left blank.

The Result can be any Result Type, but the Error needs to be convertible to `CubeOSError::Error::ServiceError(u8)`. [CubeOSError](https://github.com/Cube-OS/cubeos-error).

The $Reply requires the #[derive(Serialize,Deserialize)] from the [serde_json](https://docs.serde.rs/serde_json/) crate.

The $GqlReply is additionally available to translate digital sensory data to human readable outputs. Similar to $GqlInput, this can be set to $Reply, where the response is already humanly readable (e.g. for `GenericResponse`, or Enum or String types).
It is necessary to implement the `From` Trait to convert $Reply to $GqlReply:
```
#[derive(GraphQLObject)]
pub struct $GqReply {
...
}
impl From<$Reply> for $GqlReply {
  fn from(gql: $Reply) -> $GqlReply {
    ...
  }
}
```

## Service
To accomodate the different use cases, the `Service` has been altered slightly as well. The following examples show how to start your service in `main.rs`:

In the default UDP case, the GraphQL Query and Mutationroot are replaced by the `udp_handler` function:
```
#[cfg(not(any(feature = "ground",feature = "graphql")))]
//Start up UDP server
Service::new(
    service_config,
    subsystem,
    Some(Arc::new(udp_handler)),
)
.start();
```

The ground case, doesn't need the Subsystem, but adds a socket IP address,
which can be any free Port on the Debug/GroundStation computer, and the target service's IP address on the satellite.
It is handy to read them in from a `config.toml` file, but not necessary.
```
#[cfg(feature = "ground")]
// Start ground service
Service::new(
    service_config,
    QueryRoot,
    MutationRoot,
    socket.as_str().unwrap().to_string(),
    target.as_str().unwrap().to_string(),
).start();
```

## Compile your service (requires rust 1.55.0 or above)
As shown above, **cubeos-service** uses features so the user can decide the use case at compile time.

**UDP handling**

`cargo build`

or with cross compiler (requires KubOS SDK)

`cargo kubos -c build --target kubos-linux-isis-gcc -- --release` (for ISISpace iOBC)
`cargo kubos -c build --target kubos-linux-beaglebone-gcc -- --release` (for Beaglebone Black)

**Ground:**

`cargo build --features ground`

Additionally the UDP handling and Ground features can be combined with **debug**, e.g.:
`cargo build --features debug`
`cargo build --features ground,debug`

## Run a service
To run a service simply transfer the executable to the satellite or ground station to a desired folder (e.g. /home/kubos/) and run:

`./executable`

This requires a config file, in Kubos/Cube-OS this is commonly stored under `/etc/kubos-config.toml`. 
Alternatively run the executable with the -c flag to specify a config file:

`./executable -c /path/to/config`

### Run the Ground Service
Run the ground service on a computer connected to your OBC via SLIP or Ethernet or a radio link (which simulates an IP network) with:
`./ground_executable -c /path/to/config`

To open the GraphQL environment, use your browser to navigate to:
`$IP:$port/graphiql`

## Troubleshooting
CubeOS uses git ssh URL's for dependencies within the Organisation. Pls make sure to add your to the repository:

**start ssh-agent**
```` eval `ssh-agent` ````

**add key (in repo)**
`ssh-add ~/.ssh/$your-key`
